{% extends "base.html" %}

{% block title %}Admin Dashboard - AppManager{% endblock %}

{% block extra_head %}
<style>
    .logo-preview {
        max-width: 50px;
        max-height: 50px;
        object-fit: contain;
    }
    
    /* Terminal Styles */
    .terminal-console {
        background: #1e1e1e;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 30px;
        color: #d4d4d4;
        font-family: 'Courier New', monospace;
    }
    
    .terminal-content {
        background: #252526;
        border-radius: 5px;
        padding: 15px;
        color: #d4d4d4;
        font-family: 'Courier New', Courier, 'Liberation Mono', monospace;
        font-size: 0.9em;
        min-height: 400px;
        max-height: 600px;
        display: flex;
        flex-direction: column;
    }
    
    .terminal-output {
        flex: 1;
        overflow-y: auto;
        padding: 15px;
        line-height: 1.5;
        white-space: pre-wrap;
        word-wrap: break-word;
    }
    
    .terminal-output::-webkit-scrollbar {
        width: 10px;
    }
    
    .terminal-output::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
    }
    
    .terminal-output::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 5px;
    }
    
    .terminal-output::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
    }
    
    .terminal-line {
        margin: 2px 0;
        padding: 2px 0;
    }
    
    .terminal-line.command {
        color: #4ec9b0;
    }
    
    .terminal-line.output {
        color: #d4d4d4;
    }
    
    .terminal-line.error {
        color: #f48771;
    }
    
    .terminal-line.success {
        color: #4ec9b0;
    }
    
    .terminal-line.loading {
        color: #808080;
        font-style: italic;
    }
    
    .terminal-input-line {
        display: flex;
        align-items: center;
        padding: 10px 15px;
        background: rgba(0, 0, 0, 0.3);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .terminal-prompt {
        color: #4ec9b0;
        margin-right: 8px;
        font-weight: bold;
        user-select: none;
    }
    
    .terminal-input {
        flex: 1;
        background: transparent;
        border: none;
        color: #d4d4d4;
        font-family: 'Courier New', Courier, 'Liberation Mono', monospace;
        font-size: 0.9em;
        outline: none;
        padding: 5px 0;
    }
    
    .terminal-input:focus {
        outline: none;
    }
    
    .terminal-input::placeholder {
        color: #808080;
    }
    
    .terminal-input:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    /* Collapsible Console Styles */
    .console-header {
        cursor: pointer;
        user-select: none;
        transition: background-color 0.2s;
    }
    
    .console-header:hover {
        background-color: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
    }
    
    .console-header .chevron {
        margin-right: 10px;
        transition: transform 0.3s;
        display: inline-block;
        font-size: 0.9em;
    }
    
    .console-header:not(.collapsed) .chevron {
        transform: rotate(90deg);
    }
    
    .console-content.collapsed,
    .terminal-content.collapsed {
        display: none;
    }
    
    .console-header .header-actions-group {
        display: flex;
        gap: 10px;
        align-items: center;
    }
</style>
{% endblock %}

{% block content %}
<div class="admin-dashboard">
    <header class="dashboard-header">
        <h1>App Manager Dashboard</h1>
        <div class="header-actions">
            <a href="{{ url_for('welcome.index') }}" class="btn btn-secondary">‚Üê Back to Welcome</a>
            <a href="{{ url_for('admin.logout') }}" class="btn btn-secondary">Logout</a>
        </div>
    </header>
    
    <!-- Ports Console -->
    <div class="ports-console">
        <div class="console-header collapsed" onclick="toggleConsole('ports')">
            <h2><span class="chevron">‚ñ∂</span>Active Ports Console</h2>
            <div class="header-actions-group">
                <button class="btn btn-secondary" onclick="event.stopPropagation(); refreshPortsConsole()">üîÑ Refresh</button>
            </div>
        </div>
        <div id="ports-console-content" class="console-content collapsed">
            <p style="color: #808080; text-align: center; padding: 20px;">Loading active ports...</p>
        </div>
    </div>
    
    <!-- Terminal Console -->
    <div class="terminal-console">
        <div class="console-header collapsed" onclick="toggleConsole('terminal')">
            <h2><span class="chevron">‚ñ∂</span>Server Terminal</h2>
            <div class="header-actions-group">
                <button class="btn btn-secondary" onclick="event.stopPropagation(); clearTerminal()">üóëÔ∏è Clear</button>
            </div>
        </div>
        <div id="terminal-content" class="terminal-content collapsed">
            <div id="terminal-output" class="terminal-output"></div>
            <div class="terminal-input-line">
                <span class="terminal-prompt" id="terminal-prompt-display">~$</span>
                <input type="text" id="terminal-input" class="terminal-input" autocomplete="off" spellcheck="false" placeholder="Type a command and press Enter...">
            </div>
        </div>
    </div>
    
    <div class="apps-list">
        <div class="apps-list-header">
            <h2>Configured Applications</h2>
            <button class="btn btn-primary" onclick="showAddModal()">+ Add App</button>
        </div>
        
        <div id="apps-container" class="apps-container">
            {% for app in apps %}
            <div class="app-row" data-app-id="{{ app.id }}">
                <div class="app-row-content">
                    <div class="app-info">
                        {% if app.logo %}
                            <img src="{{ url_for('admin.uploaded_file', filename=app.logo) }}" alt="{{ app.name }}" class="logo-preview">
                        {% else %}
                            <div class="logo-placeholder-small">{{ app.name[0].upper() }}</div>
                        {% endif %}
                        <div class="app-details">
                            <h3>{{ app.name }}</h3>
                            <p>Port: {{ app.port }} | Service: {{ app.get('service_name', 'N/A') }}</p>
                        </div>
                    </div>
                    <div class="app-actions">
                        <div class="dropdown">
                            <button class="btn-icon" onclick="toggleDropdown('{{ app.id }}')">‚ãØ</button>
                            <div id="dropdown-{{ app.id }}" class="dropdown-menu">
                                <a href="#" onclick="editApp('{{ app.id }}'); return false;">Edit</a>
                                <a href="#" onclick="testApp('{{ app.id }}'); return false;">Test</a>
                                <a href="#" onclick="fixSSL('{{ app.id }}'); return false;">Fix SSL</a>
                                <a href="#" onclick="restartApp('{{ app.id }}'); return false;">Restart</a>
                                <a href="{{ url_for('admin.view_logs', app_id=app.id) }}" target="_blank">See Logs</a>
                                <a href="#" onclick="deleteApp('{{ app.id }}'); return false;" class="danger">Delete</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            {% endfor %}
            
            {% if not apps %}
            <div class="no-apps">
                <p>No apps configured. Click "Add App" to get started.</p>
            </div>
            {% endif %}
        </div>
    </div>
</div>

<!-- Add/Edit Modal -->
<div id="app-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="modal-title">Add Application</h2>
            <button class="modal-close" onclick="closeModal()">&times;</button>
        </div>
        <form id="app-form" class="modal-form" enctype="multipart/form-data">
            <input type="hidden" id="app-id" name="app_id">
            
            <div class="form-group">
                <label for="app-name">App Name *</label>
                <input type="text" id="app-name" name="name" required>
            </div>
            
            <div class="form-group">
                <label for="app-port">Port *</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" id="app-port" name="port" required min="1" max="65535" style="flex: 1;">
                    <button type="button" class="btn btn-secondary" onclick="detectServiceName()" style="white-space: nowrap;" title="Auto-detect service name from port">üîç Detect</button>
                </div>
            </div>
            
            <div class="form-group">
                <label for="app-service-name">Service Name (optional)</label>
                <input type="text" id="app-service-name" name="service_name" placeholder="e.g., calculator.service">
                <small>
                    Systemd service name for restart functionality (Linux only). 
                    Leave blank if not using systemd or running locally.
                    <br>
                    <a href="#" onclick="showServiceNameHelp(); return false;" style="color: #667eea;">How to find service name?</a>
                </small>
            </div>
            
            <div class="form-group">
                <label for="app-logo">Logo (optional)</label>
                <input type="file" id="app-logo" name="logo" accept="image/*">
                <div id="logo-preview-container"></div>
            </div>
            
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button type="submit" class="btn btn-primary">Save</button>
            </div>
        </form>
    </div>
</div>

<!-- Test Results Modal -->
<div id="test-results-modal" class="modal">
    <div class="modal-content test-results-modal-content">
        <div class="modal-header">
            <h2>Test Results</h2>
            <button class="modal-close" onclick="closeTestResultsModal()">&times;</button>
        </div>
        <div id="test-results-content" class="test-results-content">
            <!-- Test results will be populated here -->
        </div>
    </div>
</div>
    </div>
</div>

<script>
let currentEditingId = null;

function showAddModal(port = null, serviceName = null) {
    currentEditingId = null;
    document.getElementById('modal-title').textContent = 'Add Application';
    document.getElementById('app-form').reset();
    document.getElementById('app-id').value = '';
    document.getElementById('logo-preview-container').innerHTML = '';
    
    // Pre-fill port and service name if provided
    if (port !== null) {
        document.getElementById('app-port').value = port;
    }
    if (serviceName) {
        document.getElementById('app-service-name').value = serviceName;
    }
    
    document.getElementById('app-modal').style.display = 'block';
}

function addAppFromPort(port, serviceName) {
    showAddModal(port, serviceName || '');
}

function editApp(appId) {
    currentEditingId = appId;
    document.getElementById('modal-title').textContent = 'Edit Application';
    
    // Fetch app data
    fetch(`/admin/api/apps`)
        .then(r => r.json())
        .then(data => {
            const app = data.apps.find(a => a.id === appId);
            if (app) {
                document.getElementById('app-id').value = app.id;
                document.getElementById('app-name').value = app.name;
                document.getElementById('app-port').value = app.port;
                document.getElementById('app-service-name').value = app.service_name || '';
                
                if (app.logo) {
                    document.getElementById('logo-preview-container').innerHTML = 
                        `<img src="/admin/uploads/${app.logo}" class="logo-preview" style="margin-top: 10px;">`;
                }
                
                document.getElementById('app-modal').style.display = 'block';
            }
        });
}

function closeModal() {
    document.getElementById('app-modal').style.display = 'none';
    currentEditingId = null;
}

function toggleDropdown(appId) {
    const dropdown = document.getElementById(`dropdown-${appId}`);
    const appRow = dropdown.closest('.app-row');
    // Close all other dropdowns
    document.querySelectorAll('.dropdown-menu').forEach(menu => {
        if (menu.id !== `dropdown-${appId}`) {
            menu.style.display = 'none';
            menu.closest('.app-row')?.classList.remove('dropdown-open');
        }
    });
    if (dropdown.style.display === 'block') {
        dropdown.style.display = 'none';
        appRow?.classList.remove('dropdown-open');
    } else {
        dropdown.style.display = 'block';
        appRow?.classList.add('dropdown-open');
    }
}

// Close dropdowns when clicking outside
document.addEventListener('click', (e) => {
    if (!e.target.closest('.dropdown')) {
        document.querySelectorAll('.dropdown-menu').forEach(menu => {
            menu.style.display = 'none';
            menu.closest('.app-row')?.classList.remove('dropdown-open');
        });
    }
});

// Alert banner management
function showAlert(message, type = 'warning') {
    // Remove existing alerts
    const existingAlerts = document.querySelectorAll('.alert-banner');
    existingAlerts.forEach(alert => alert.remove());
    
    // Create new alert
    const alert = document.createElement('div');
    alert.className = `alert-banner ${type}`;
    alert.innerHTML = `
        <span class="alert-icon">${type === 'error' ? '‚ö†Ô∏è' : '‚ö†Ô∏è'}</span>
        <span class="alert-message">${message}</span>
        <button class="alert-close" onclick="this.parentElement.remove()">&times;</button>
    `;
    
    // Insert at top of apps-list
    const appsList = document.querySelector('.apps-list');
    appsList.insertBefore(alert, appsList.firstChild);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
        if (alert.parentElement) {
            alert.remove();
        }
    }, 10000);
}

// Ports Console
async function refreshPortsConsole() {
    const content = document.getElementById('ports-console-content');
    content.innerHTML = '<p style="color: #808080; text-align: center; padding: 20px;">Loading...</p>';
    
    try {
        const response = await fetch('/admin/api/active-ports');
        const result = await response.json();
        
        if (result.success && result.ports && result.ports.length > 0) {
            let html = '<table><thead><tr><th>Port</th><th>Service Name</th><th>PID</th><th>Action</th></tr></thead><tbody>';
            result.ports.forEach(item => {
                const serviceName = item.service_name || '';
                html += `<tr>
                    <td class="port-number">${item.port}</td>
                    <td class="${item.service_name ? 'service-name' : 'no-service'}">${item.service_name || '(no service)'}</td>
                    <td class="pid-info">${item.pid || 'N/A'}</td>
                    <td><button class="btn-add-port" data-port="${item.port}" data-service-name="${serviceName.replace(/"/g, '&quot;')}" title="Add as configured application">+</button></td>
                </tr>`;
            });
            html += '</tbody></table>';
            content.innerHTML = html;
            
            // Attach event listeners to all add buttons
            content.querySelectorAll('.btn-add-port').forEach(btn => {
                btn.addEventListener('click', function() {
                    const port = parseInt(this.getAttribute('data-port'));
                    const serviceName = this.getAttribute('data-service-name') || '';
                    addAppFromPort(port, serviceName);
                });
            });
        } else {
            content.innerHTML = '<p style="color: #808080; text-align: center; padding: 20px;">No active ports found or detection not available.</p>';
        }
    } catch (error) {
        content.innerHTML = `<p style="color: #dc3545; text-align: center; padding: 20px;">Error loading ports: ${error.message}</p>`;
    }
}

// Toggle console collapse/expand
function toggleConsole(type) {
    const header = document.querySelector(`.${type === 'ports' ? 'ports-console' : 'terminal-console'} .console-header`);
    const content = document.getElementById(type === 'ports' ? 'ports-console-content' : 'terminal-content');
    
    if (header && content) {
        const isCollapsed = header.classList.contains('collapsed');
        
        if (isCollapsed) {
            header.classList.remove('collapsed');
            content.classList.remove('collapsed');
        } else {
            header.classList.add('collapsed');
            content.classList.add('collapsed');
        }
    }
}

// Load ports console on page load
document.addEventListener('DOMContentLoaded', () => {
    refreshPortsConsole();
    initializeTerminal();
});

// Terminal functionality
let terminalHistory = [];
let terminalHistoryIndex = -1;
let currentCommand = '';
let currentWorkingDirectory = '~';
let autocompleteMatches = [];
let autocompleteIndex = -1;
let lastAutocompleteQuery = '';

function updateTerminalPrompt() {
    const promptDisplay = document.getElementById('terminal-prompt-display');
    if (promptDisplay) {
        const displayDir = currentWorkingDirectory === '~' ? '~' : currentWorkingDirectory;
        promptDisplay.textContent = displayDir + '$';
    }
}

function initializeTerminal() {
    const terminalInput = document.getElementById('terminal-input');
    const terminalOutput = document.getElementById('terminal-output');
    
    if (!terminalInput || !terminalOutput) return;
    
    // Update prompt display
    updateTerminalPrompt();
    
    // Welcome message
    addTerminalLine('output', 'Welcome to AppManager Server Terminal');
    addTerminalLine('output', 'Type commands to execute on the server. Use "help" for available commands.');
    addTerminalLine('output', 'Press TAB for file/folder autocomplete.');
    addTerminalLine('output', '');
    
    // Focus input
    terminalInput.focus();
    
    // Handle Enter key
    terminalInput.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const command = terminalInput.value.trim();
            if (command) {
                executeCommand(command);
                terminalInput.value = '';
                terminalHistoryIndex = -1;
                autocompleteMatches = [];
                autocompleteIndex = -1;
            }
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (terminalHistory.length > 0) {
                if (terminalHistoryIndex === -1) {
                    currentCommand = terminalInput.value;
                    terminalHistoryIndex = terminalHistory.length;
                }
                terminalHistoryIndex = Math.max(0, terminalHistoryIndex - 1);
                terminalInput.value = terminalHistory[terminalHistoryIndex];
                autocompleteMatches = [];
                autocompleteIndex = -1;
            }
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (terminalHistoryIndex >= 0) {
                terminalHistoryIndex = Math.min(terminalHistory.length - 1, terminalHistoryIndex + 1);
                if (terminalHistoryIndex === terminalHistory.length - 1) {
                    terminalInput.value = currentCommand;
                    terminalHistoryIndex = -1;
                } else {
                    terminalInput.value = terminalHistory[terminalHistoryIndex];
                }
                autocompleteMatches = [];
                autocompleteIndex = -1;
            }
        } else if (e.key === 'Tab') {
            e.preventDefault();
            await handleTabCompletion(terminalInput);
        }
    });
    
    // Keep focus on input when clicking terminal
    terminalOutput.addEventListener('click', () => {
        terminalInput.focus();
    });
}

async function handleTabCompletion(input) {
    const value = input.value;
    const cursorPos = input.selectionStart;
    
    // Extract the word at cursor position (could be a path)
    const textBeforeCursor = value.substring(0, cursorPos);
    const textAfterCursor = value.substring(cursorPos);
    
    // Find the start of the current word/path
    // Look for spaces or start of line
    let wordStart = textBeforeCursor.length;
    for (let i = textBeforeCursor.length - 1; i >= 0; i--) {
        if (textBeforeCursor[i] === ' ' || textBeforeCursor[i] === '\t') {
            wordStart = i + 1;
            break;
        }
        if (i === 0) {
            wordStart = 0;
        }
    }
    
    const partialPath = textBeforeCursor.substring(wordStart);
    
    // If no partial path, don't autocomplete
    if (!partialPath) {
        return;
    }
    
    // Get autocomplete suggestions
    try {
        const response = await fetch('/admin/api/terminal/autocomplete', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                path: partialPath,
                cwd: currentWorkingDirectory
            })
        });
        
        const result = await response.json();
        
        if (result.matches && result.matches.length > 0) {
            // Check if this is the same query (for cycling through matches)
            if (partialPath === lastAutocompleteQuery && autocompleteMatches.length > 0) {
                // Cycle to next match
                autocompleteIndex = (autocompleteIndex + 1) % autocompleteMatches.length;
            } else {
                // New query, reset
                autocompleteMatches = result.matches;
                autocompleteIndex = 0;
                lastAutocompleteQuery = partialPath;
            }
            
            const match = autocompleteMatches[autocompleteIndex];
            const dirPart = partialPath.includes('/') ? partialPath.substring(0, partialPath.lastIndexOf('/') + 1) : '';
            const completedPath = dirPart + match.name;
            
            // If it's a directory, add trailing slash
            const finalPath = match.is_directory ? completedPath + '/' : completedPath;
            
            // Replace the partial path with completed path
            const newValue = textBeforeCursor.substring(0, wordStart) + finalPath + textAfterCursor;
            input.value = newValue;
            
            // Set cursor position after completed path
            const newCursorPos = wordStart + finalPath.length;
            input.setSelectionRange(newCursorPos, newCursorPos);
            
            // If multiple matches, show hint
            if (autocompleteMatches.length > 1) {
                // Show matches in terminal (temporary, will be cleared on next command)
                const matchList = autocompleteMatches.map((m, i) => {
                    const marker = i === autocompleteIndex ? '>' : ' ';
                    const type = m.is_directory ? '/' : '';
                    return `${marker} ${m.name}${type}`;
                }).join('  ');
                
                // Add hint line (will be cleared when user types)
                const hintLine = document.createElement('div');
                hintLine.className = 'terminal-line output';
                hintLine.style.color = '#808080';
                hintLine.style.fontSize = '0.85em';
                hintLine.textContent = `Matches (${autocompleteIndex + 1}/${autocompleteMatches.length}): ${matchList}`;
                hintLine.id = 'autocomplete-hint';
                
                // Remove previous hint if exists
                const prevHint = document.getElementById('autocomplete-hint');
                if (prevHint) {
                    prevHint.remove();
                }
                
                const terminalOutput = document.getElementById('terminal-output');
                terminalOutput.appendChild(hintLine);
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
            }
        }
    } catch (error) {
        // Silently fail on autocomplete errors
        console.error('Autocomplete error:', error);
    }
}

function addTerminalLine(type, text) {
    const terminalOutput = document.getElementById('terminal-output');
    if (!terminalOutput) return;
    
    const line = document.createElement('div');
    line.className = `terminal-line ${type}`;
    line.textContent = text;
    terminalOutput.appendChild(line);
    
    // Auto-scroll to bottom
    terminalOutput.scrollTop = terminalOutput.scrollHeight;
}

function clearTerminal() {
    const terminalOutput = document.getElementById('terminal-output');
    if (terminalOutput) {
        terminalOutput.innerHTML = '';
        addTerminalLine('output', 'Terminal cleared.');
        addTerminalLine('output', '');
    }
}

async function executeCommand(command) {
    const terminalOutput = document.getElementById('terminal-output');
    const terminalInput = document.getElementById('terminal-input');
    
    if (!terminalOutput || !terminalInput) return;
    
    // Remove autocomplete hint if exists
    const hint = document.getElementById('autocomplete-hint');
    if (hint) {
        hint.remove();
    }
    
    // Reset autocomplete state
    autocompleteMatches = [];
    autocompleteIndex = -1;
    lastAutocompleteQuery = '';
    
    // Add command to history
    if (command && (terminalHistory.length === 0 || terminalHistory[terminalHistory.length - 1] !== command)) {
        terminalHistory.push(command);
        if (terminalHistory.length > 100) {
            terminalHistory.shift(); // Keep last 100 commands
        }
    }
    
    // Display command with current directory
    const promptDir = currentWorkingDirectory === '~' ? '~' : currentWorkingDirectory;
    addTerminalLine('command', `${promptDir}$ ${command}`);
    
    // Handle special commands
    if (command === 'clear' || command === 'cls') {
        clearTerminal();
        return;
    }
    
    // Note: cd command handling is now done server-side and returned in response
    
    if (command === 'help') {
        addTerminalLine('output', 'Available commands:');
        addTerminalLine('output', '  ls, cd, pwd, cat, head, tail, grep, find');
        addTerminalLine('output', '  ps, df, du, free, uptime, whoami, uname');
        addTerminalLine('output', '  systemctl, journalctl, netstat, ss');
        addTerminalLine('output', '  git, python3, pip, npm, docker');
        addTerminalLine('output', '  nginx, certbot, ufw, iptables');
        addTerminalLine('output', '');
        addTerminalLine('output', 'Shell Scripts:');
        addTerminalLine('output', '  bash script.sh - Run a shell script');
        addTerminalLine('output', '  sh script.sh - Run a shell script');
        addTerminalLine('output', '  ./script.sh - Run an executable script');
        addTerminalLine('output', '  Scripts must be in: ~, /opt/appmanager, or /tmp');
        addTerminalLine('output', '');
        addTerminalLine('output', 'Terminal Commands:');
        addTerminalLine('output', '  clear - Clear terminal');
        addTerminalLine('output', '  help - Show this help message');
        addTerminalLine('output', '');
        return;
    }
    
    // Show loading indicator
    const loadingLine = document.createElement('div');
    loadingLine.className = 'terminal-line loading';
    loadingLine.textContent = 'Executing...';
    terminalOutput.appendChild(loadingLine);
    terminalOutput.scrollTop = terminalOutput.scrollHeight;
    
    // Disable input during execution
    terminalInput.disabled = true;
    
    try {
        const response = await fetch('/admin/api/terminal/execute', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                command: command,
                cwd: currentWorkingDirectory
            })
        });
        
        // Remove loading indicator
        loadingLine.remove();
        
        const result = await response.json();
        
        if (result.success) {
            // Update working directory if returned
            if (result.cwd) {
                currentWorkingDirectory = result.cwd;
                updateTerminalPrompt();
            }
            
            // Display output
            if (result.output) {
                const lines = result.output.split('\n');
                lines.forEach(line => {
                    addTerminalLine('output', line);
                });
            } else {
                // For cd command, don't show "(no output)" - it's normal
                if (!command.startsWith('cd ')) {
                    addTerminalLine('output', '(no output)');
                }
            }
            
            // Show exit code if non-zero
            if (result.exit_code !== 0) {
                addTerminalLine('error', `[Exit code: ${result.exit_code}]`);
            }
        } else {
            // Even on error, update cwd if provided (to maintain state)
            if (result.cwd) {
                currentWorkingDirectory = result.cwd;
                updateTerminalPrompt();
            }
            addTerminalLine('error', `Error: ${result.error || 'Unknown error'}`);
            if (result.hint) {
                addTerminalLine('output', result.hint);
            }
        }
    } catch (error) {
        loadingLine.remove();
        addTerminalLine('error', `Network error: ${error.message}`);
    } finally {
        terminalInput.disabled = false;
        terminalInput.focus();
        addTerminalLine('output', ''); // Empty line after command
    }
}

document.getElementById('app-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const appId = document.getElementById('app-id').value;
    
    try {
        let response;
        if (appId) {
            // Update
            const data = {
                name: formData.get('name'),
                port: parseInt(formData.get('port')),
                service_name: formData.get('service_name') || null,
                logo: formData.get('logo') ? null : document.querySelector('#logo-preview-container img')?.src.split('/static/')[1] || null
            };
            
            if (formData.get('logo') && formData.get('logo').size > 0) {
                // Has new logo file
                const updateFormData = new FormData();
                updateFormData.append('name', data.name);
                updateFormData.append('port', data.port);
                updateFormData.append('service_name', data.service_name || '');
                updateFormData.append('logo', formData.get('logo'));
                
                response = await fetch(`/admin/api/apps/${appId}`, {
                    method: 'PUT',
                    body: updateFormData
                });
            } else {
                response = await fetch(`/admin/api/apps/${appId}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
            }
        } else {
            // Create
            response = await fetch('/admin/api/apps', {
                method: 'POST',
                body: formData
            });
        }
        
        const result = await response.json();
        
        if (result.success) {
            // Refresh ports console
            refreshPortsConsole();
            location.reload();
        } else {
            // Show error banner instead of alert
            const errorMsg = result.error || 'Unknown error';
            showAlert(errorMsg, 'error');
            
            // If it's a port listening error, highlight the port field
            if (result.is_listening === false) {
                document.getElementById('app-port').style.borderColor = '#dc3545';
                document.getElementById('app-port').focus();
            }
        }
    } catch (error) {
        showAlert('Error: ' + error.message, 'error');
    }
});

function closeTestResultsModal() {
    document.getElementById('test-results-modal').style.display = 'none';
}

async function testApp(appId) {
    try {
        // Show loading state
        const modal = document.getElementById('test-results-modal');
        const content = document.getElementById('test-results-content');
        content.innerHTML = '<p style="text-align: center; padding: 40px; color: #b0b0b0;">Testing app connectivity...</p>';
        modal.style.display = 'block';
        
        const response = await fetch(`/admin/api/apps/${appId}/test`, {
            method: 'POST'
        });
        const result = await response.json();
        
        // Build HTML content for test results
        let html = '<div class="test-results">';
        
        // Socket listening test
        html += '<div class="test-section">';
        html += '<h3>Socket Test</h3>';
        html += '<div class="test-result ' + (result.is_listening ? 'success' : 'error') + '">';
        html += result.is_listening 
            ? '<span class="test-icon">‚úì</span><span>Port ' + result.port + ' is listening</span>'
            : '<span class="test-icon">‚úó</span><span>Port ' + result.port + ' is NOT listening</span>';
        html += '</div>';
        html += '</div>';
        
        // HTTP test
        html += '<div class="test-section">';
        html += '<h3>HTTP Test (Port ' + result.port + ')</h3>';
        const httpIsSuccessful = result.http.accessible && result.http.successful;
        html += '<div class="test-result ' + (httpIsSuccessful ? 'success' : 'error') + '">';
        if (result.http.accessible) {
            const status = typeof result.http.status === 'number' ? 'HTTP ' + result.http.status : result.http.status;
            if (result.http.successful) {
                html += '<span class="test-icon">‚úì</span><span>Accessible - ' + status + '</span>';
            } else {
                html += '<span class="test-icon">‚úó</span><span>Error - ' + status + '</span>';
                if (typeof result.http.status === 'number' && result.http.status === 404) {
                    html += '<div class="test-warning">‚ö† Resource not found (404) - App may not be responding correctly</div>';
                } else if (typeof result.http.status === 'number' && result.http.status >= 500) {
                    html += '<div class="test-warning">‚ö† Server error (' + result.http.status + ') - App is returning an error</div>';
                }
            }
        } else {
            html += '<span class="test-icon">‚úó</span><span>NOT accessible - ' + result.http.status + '</span>';
        }
        html += '</div>';
        html += '<div class="test-url"><strong>URL:</strong> <code>' + result.http.url + '</code></div>';
        html += '</div>';
        
        // HTTPS test
        html += '<div class="test-section">';
        html += '<h3>HTTPS Test (Port ' + result.https.port + ')</h3>';
        const httpsIsSuccessful = result.https.accessible && result.https.successful;
        html += '<div class="test-result ' + (httpsIsSuccessful ? 'success' : 'error') + '">';
        if (result.https.accessible) {
            const status = typeof result.https.status === 'number' ? 'HTTP ' + result.https.status : result.https.status;
            if (result.https.successful) {
                html += '<span class="test-icon">‚úì</span><span>Accessible - ' + status + '</span>';
            } else {
                html += '<span class="test-icon">‚úó</span><span>Error - ' + status + '</span>';
                if (result.https.status === 'SSL_ERROR') {
                    html += '<div class="test-warning">‚ö† SSL certificate issue detected (certificate not trusted)</div>';
                } else if (typeof result.https.status === 'number' && result.https.status === 404) {
                    html += '<div class="test-warning">‚ö† Resource not found (404) - App may not be responding correctly</div>';
                } else if (typeof result.https.status === 'number' && result.https.status >= 500) {
                    html += '<div class="test-warning">‚ö† Server error (' + result.https.status + ') - App is returning an error</div>';
                }
            }
        } else {
            html += '<span class="test-icon">‚úó</span><span>NOT accessible - ' + result.https.status + '</span>';
        }
        html += '</div>';
        html += '<div class="test-url"><strong>URL:</strong> <code>' + result.https.url + '</code></div>';
        
        // SSL Certificate Status
        if (result.https.certificate_status) {
            const certStatus = result.https.certificate_status;
            html += '<div class="test-cert-info" style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">';
            html += '<strong>SSL Certificate Status:</strong><br>';
            html += '‚Ä¢ Nginx Configured: ' + (certStatus.nginx_configured ? '‚úì Yes' : '‚úó No') + '<br>';
            html += '‚Ä¢ Certificate Exists: ' + (certStatus.certificate_exists ? '‚úì Yes' : '‚úó No') + '<br>';
            html += '‚Ä¢ Certificate Trusted: ' + (certStatus.certificate_trusted ? '‚úì Yes (Let\'s Encrypt)' : '‚úó No') + '<br>';
            if (certStatus.certificate_path) {
                html += '‚Ä¢ Certificate Path: <code style="font-size: 0.9em;">' + certStatus.certificate_path + '</code><br>';
            }
            if (certStatus.certificate_info) {
                const certInfo = certStatus.certificate_info;
                if (certInfo.issuer) {
                    html += '‚Ä¢ Issuer: ' + (certInfo.issuer.get('organizationName') || certInfo.issuer.get('CN') || 'Unknown') + '<br>';
                }
                if (certInfo.expires) {
                    html += '‚Ä¢ Expires: ' + certInfo.expires + '<br>';
                }
                if (certInfo.error) {
                    html += '‚Ä¢ Error: <span style="color: #f48771;">' + certInfo.error + '</span><br>';
                }
            }
            if (certStatus.error) {
                html += '‚Ä¢ Error: <span style="color: #f48771;">' + certStatus.error + '</span><br>';
            }
            html += '</div>';
        }
        html += '</div>';
        
        // Masked Path Test (HTTP)
        if (result.masked_path && result.masked_path.http) {
            html += '<div class="test-section">';
            html += '<h3>Masked Path Test - HTTP (/' + result.app_slug + '/)</h3>';
            const maskedHttpSuccessful = result.masked_path.http.accessible && result.masked_path.http.successful;
            html += '<div class="test-result ' + (maskedHttpSuccessful ? 'success' : 'error') + '">';
            if (result.masked_path.http.accessible) {
                const status = typeof result.masked_path.http.status === 'number' ? 'HTTP ' + result.masked_path.http.status : result.masked_path.http.status;
                if (result.masked_path.http.successful) {
                    html += '<span class="test-icon">‚úì</span><span>Accessible - ' + status + '</span>';
                } else {
                    html += '<span class="test-icon">‚úó</span><span>Error - ' + status + '</span>';
                    if (typeof result.masked_path.http.status === 'number' && result.masked_path.http.status === 404) {
                        html += '<div class="test-warning">‚ö† Resource not found (404) - App may not be responding correctly</div>';
                    } else if (typeof result.masked_path.http.status === 'number' && result.masked_path.http.status >= 500) {
                        html += '<div class="test-warning">‚ö† Server error (' + result.masked_path.http.status + ') - App is returning an error</div>';
                    }
                }
            } else {
                html += '<span class="test-icon">‚úó</span><span>NOT accessible - ' + result.masked_path.http.status + '</span>';
            }
            html += '</div>';
            html += '<div class="test-url"><strong>URL:</strong> <code>' + result.masked_path.http.url + '</code></div>';
            html += '</div>';
        }
        
        // Masked Path Test (HTTPS)
        if (result.masked_path && result.masked_path.https) {
            html += '<div class="test-section">';
            html += '<h3>Masked Path Test - HTTPS (/' + result.app_slug + '/)</h3>';
            const maskedHttpsSuccessful = result.masked_path.https.accessible && result.masked_path.https.successful;
            html += '<div class="test-result ' + (maskedHttpsSuccessful ? 'success' : 'error') + '">';
            if (result.masked_path.https.accessible) {
                const status = typeof result.masked_path.https.status === 'number' ? 'HTTP ' + result.masked_path.https.status : result.masked_path.https.status;
                if (result.masked_path.https.successful) {
                    html += '<span class="test-icon">‚úì</span><span>Accessible - ' + status + '</span>';
                } else {
                    html += '<span class="test-icon">‚úó</span><span>Error - ' + status + '</span>';
                    if (typeof result.masked_path.https.status === 'number' && result.masked_path.https.status === 404) {
                        html += '<div class="test-warning">‚ö† Resource not found (404) - App may not be responding correctly</div>';
                    } else if (typeof result.masked_path.https.status === 'number' && result.masked_path.https.status >= 500) {
                        html += '<div class="test-warning">‚ö† Server error (' + result.masked_path.https.status + ') - App is returning an error</div>';
                    }
                }
            } else {
                html += '<span class="test-icon">‚úó</span><span>NOT accessible - ' + result.masked_path.https.status + '</span>';
            }
            html += '</div>';
            html += '<div class="test-url"><strong>URL:</strong> <code>' + result.masked_path.https.url + '</code></div>';
            html += '</div>';
        }
        
        html += '</div>';
        
        content.innerHTML = html;
    } catch (error) {
        const content = document.getElementById('test-results-content');
        content.innerHTML = '<div class="test-error"><p>Error testing app: ' + error.message + '</p></div>';
    }
}

// Close modal when clicking outside
document.getElementById('test-results-modal').addEventListener('click', function(e) {
    if (e.target === this) {
        closeTestResultsModal();
    }
});

async function fixSSL(appId) {
    if (!confirm('This will recreate the SSL certificate and nginx configuration for this app.\n\nThis ensures HTTPS works properly with proper signatures.\n\nContinue?')) {
        return;
    }
    
    // Close dropdown
    const dropdown = document.getElementById(`dropdown-${appId}`);
    if (dropdown) {
        dropdown.style.display = 'none';
        dropdown.closest('.app-row')?.classList.remove('dropdown-open');
    }
    
    try {
        const response = await fetch(`/admin/api/apps/${appId}/fix-ssl`, {
            method: 'POST'
        });
        const result = await response.json();
        
        if (result.success) {
            let message = '‚úì SSL fixed successfully!\n\n';
            message += result.message || 'SSL certificate and nginx configuration updated.';
            
            if (result.certificate_info) {
                message += `\n\nCertificate Type: ${result.certificate_info.type}`;
                if (result.certificate_info.trusted) {
                    message += '\n‚úì Using trusted certificate (browsers will trust it)';
                } else {
                    message += '\n‚ö† Certificate is not trusted';
                    message += '\n\nPlease set up Let\'s Encrypt for trusted certificates.';
                }
            }
            
            alert(message);
        } else {
            alert('‚úó Error: ' + (result.error || 'Unknown error'));
        }
    } catch (error) {
        alert('Error fixing SSL: ' + error.message);
    }
}

async function restartApp(appId) {
    if (!confirm('Are you sure you want to restart this app?')) {
        return;
    }
    
    try {
        const response = await fetch(`/admin/api/apps/${appId}/restart`, {
            method: 'POST'
        });
        const result = await response.json();
        
        if (result.success) {
            alert('‚úì ' + (result.message || 'App restarted successfully'));
        } else {
            alert('‚úó Error: ' + (result.error || 'Unknown error'));
        }
    } catch (error) {
        alert('Error restarting app: ' + error.message);
    }
}

async function deleteApp(appId) {
    if (!confirm('Are you sure you want to delete this app? This cannot be undone.')) {
        return;
    }
    
    try {
        const response = await fetch(`/admin/api/apps/${appId}`, {
            method: 'DELETE'
        });
        const result = await response.json();
        
        if (result.success) {
            location.reload();
        } else {
            alert('Error: ' + (result.error || 'Unknown error'));
        }
    } catch (error) {
        alert('Error deleting app: ' + error.message);
    }
}

// Logo preview
document.getElementById('app-logo').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            document.getElementById('logo-preview-container').innerHTML = 
                `<img src="${e.target.result}" class="logo-preview" style="margin-top: 10px;">`;
        };
        reader.readAsDataURL(file);
    }
});

function showServiceNameHelp() {
    alert('Service Name Help:\n\n' +
          'The service name is the systemd service name for your app on Linux servers.\n\n' +
          'To find it:\n' +
          '1. Click the "üîç Detect" button next to the Port field to auto-detect\n' +
          '2. Or on your server, run: sudo systemctl list-units --type=service\n' +
          '3. Look for your app (e.g., calculator.service, quizia.service)\n' +
          '4. Or check: ls /etc/systemd/system/*.service\n\n' +
          'Examples:\n' +
          '- calculator.service (for Calculator app)\n' +
          '- quizia.service (for Quizia app)\n' +
          '- deltabooks.service (for DeltaBooks app)\n\n' +
          'Note: Leave blank if:\n' +
          '- Running locally (not on Linux server)\n' +
          '- Not using systemd\n' +
          '- Don\'t need restart functionality\n\n' +
          'See SERVICE_NAME_GUIDE.md for more details.');
}

async function detectServiceName() {
    const port = document.getElementById('app-port').value;
    if (!port) {
        alert('Please enter a port number first');
        return;
    }
    
    const detectBtn = event.target;
    const originalText = detectBtn.textContent;
    detectBtn.disabled = true;
    detectBtn.textContent = 'Detecting...';
    
    try {
        const response = await fetch(`/admin/api/detect-service/${port}`);
        const result = await response.json();
        
        if (result.success && result.service_name) {
            document.getElementById('app-service-name').value = result.service_name;
            alert(`‚úì Detected service: ${result.service_name}`);
        } else {
            alert('Could not detect service name for this port.\n\n' +
                  'This might mean:\n' +
                  '- No service is running on this port\n' +
                  '- Not running on Linux with systemd\n' +
                  '- Service detection is not available\n\n' +
                  'You can still manually enter the service name.');
        }
    } catch (error) {
        alert('Error detecting service: ' + error.message);
    } finally {
        detectBtn.disabled = false;
        detectBtn.textContent = originalText;
    }
}
</script>
{% endblock %}

