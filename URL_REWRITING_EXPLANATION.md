# URL Rewriting Explanation

## 1. How the `processedUrls` Set Works

The `processedUrls` Set is a global Set (`window.__APP_MANAGER_PROCESSED_URLS`) that tracks URLs that have been processed by the `rewriteUrl()` function.

### Flow:

1. **JavaScript code calls `fetch('/api/calculate')`**
2. **Our override intercepts:** `window.fetch` override calls `rewriteUrl('/api/calculate')`
3. **Check Set:** `if (processedUrls.has('/api/calculate'))` → No, not in Set
4. **Add to Set:** `processedUrls.add('/api/calculate')` (mark as processing)
5. **Rewrite:** Create `/alpha/api/calculate`
6. **Add rewritten to Set:** `processedUrls.add('/alpha/api/calculate')` (prevent re-processing)
7. **Return:** `/alpha/api/calculate`

### If the same URL is processed again:

1. **Same URL comes through:** `rewriteUrl('/api/calculate')` called again
2. **Check Set:** `if (processedUrls.has('/api/calculate'))` → **YES, in Set**
3. **Return immediately:** Return `/api/calculate` as-is (don't rewrite again)

### Why This Works:

- **Tracks processing, not prefix content:** We don't check if URL contains prefix string
- **Global scope:** Persists across script re-runs and page reloads
- **Prevents double-processing:** Once a URL is in the Set, it's never processed again

---

## 2. Edge Case: App Named "alpha" with Routes "/temp" and "/alpha/temp"

### Scenario:
- App slug: `alpha`
- App has two routes:
  - `@app.route('/temp')` → Route handler for `/temp`
  - `@app.route('/alpha/temp')` → Route handler for `/alpha/temp`

### What Happens:

#### Route `/temp`:
- **Public URL:** `https://domain.com/alpha/temp`
- **Proxy receives:** `/alpha/temp` → strips prefix → forwards `/temp` to app
- **App receives:** `/temp` → matches `@app.route('/temp')` ✅
- **App generates URL:** `url_for('temp_route')` → ProxyFix adds prefix → `/alpha/temp` ✅

#### Route `/alpha/temp`:
- **Public URL:** `https://domain.com/alpha/alpha/temp`
- **Proxy receives:** `/alpha/alpha/temp` → strips first prefix → forwards `/alpha/temp` to app
- **App receives:** `/alpha/temp` → matches `@app.route('/alpha/temp')` ✅
- **App generates URL:** `url_for('alpha_temp_route')` → ProxyFix adds prefix → `/alpha/alpha/temp` ✅

### Problem with Current Implementation:

If the app generates a URL for route `/alpha/temp` using `url_for()`:
- ProxyFix adds prefix: `/alpha/alpha/temp` (correct for server-side)
- This URL appears in HTML: `<a href="/alpha/alpha/temp">`
- Browser reads this URL (already has prefix, correct)
- But if JavaScript code uses this URL: `fetch('/alpha/alpha/temp')`
- Our script sees `/alpha/alpha/temp` and checks if it starts with `/alpha/`
- It does! So our script might skip it (good) OR process it incorrectly

### Current Protection:

The `processedUrls` Set prevents this because:
- If the URL `/alpha/alpha/temp` comes from HTML (already prefixed by ProxyFix), it's used as-is by the browser
- If JavaScript code uses it, our script checks the Set first
- If it's already processed, we return it as-is

**However, there's still a potential issue:** If the app's JavaScript code has a hardcoded URL like `fetch('/alpha/temp')` (without prefix), our script will add prefix to make it `/alpha/alpha/temp`, which is correct!

---

## 3. Why Do We Need Rewriting at All?

### The Key Insight: ProxyFix Only Affects Server-Side URL Generation

**ProxyFix processes:**
- ✅ `url_for('route_name')` in Python templates
- ✅ `url_for('static', filename='...')` in templates
- ✅ `redirect(url_for(...))` in Python code
- ✅ Any server-side URL generation using Flask's URL building

**ProxyFix does NOT process:**
- ❌ Hardcoded strings in JavaScript: `fetch('/api/calculate')`
- ❌ JavaScript variables: `const url = '/api/data'; fetch(url)`
- ❌ JavaScript template literals: `` fetch(`/api/${id}`) ``
- ❌ JavaScript code in `<script>` tags
- ❌ JavaScript in external `.js` files
- ❌ Dynamic URL construction in JavaScript

### Example:

```python
# Server-side (Python template) - ProxyFix handles this
<a href="{{ url_for('api_route') }}">API</a>
# ProxyFix adds prefix → <a href="/alpha/api">API</a> ✅
```

```javascript
// Client-side (JavaScript) - ProxyFix does NOT handle this
fetch('/api/calculate', {...})
// This is just a string literal - ProxyFix never sees it ❌
// Our script must add prefix → fetch('/alpha/api/calculate', {...}) ✅
```

### Why This Matters:

1. **Server-side URLs:** Generated by `url_for()` → ProxyFix adds prefix → Already correct ✅
2. **Client-side URLs:** Hardcoded strings in JavaScript → ProxyFix can't process → Need our script ✅

### The Complete Flow:

```
Browser Request: https://domain.com/alpha/
  ↓
AppManager Proxy: Receives request, sets X-Forwarded-Prefix: /alpha
  ↓
App (with ProxyFix): Receives request, ProxyFix reads X-Forwarded-Prefix
  ↓
App generates HTML:
  - Server-side: url_for('api') → ProxyFix adds prefix → /alpha/api ✅
  - Client-side: JavaScript has fetch('/api/calculate') → ProxyFix can't process ❌
  ↓
AppManager injects script: Client-side script intercepts fetch()
  ↓
JavaScript fetch('/api/calculate'):
  - Our script intercepts
  - rewriteUrl('/api/calculate') → /alpha/api/calculate ✅
  - Makes request to /alpha/api/calculate
```

---

## Summary

1. **processedUrls Set:** Tracks which URLs have been processed to prevent double-processing, regardless of prefix content.

2. **Edge case (alpha/alpha/temp):** Works correctly because:
   - Server-side URLs from ProxyFix are already correct
   - Client-side URLs are tracked in the Set
   - Once processed, URLs are never processed again

3. **Why rewriting is needed:** ProxyFix only processes server-side URL generation (`url_for()`). Client-side JavaScript code with hardcoded URLs (`fetch('/api/calculate')`) is NOT processed by ProxyFix, so our client-side script must handle it.

